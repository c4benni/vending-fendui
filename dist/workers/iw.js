"use strict";self.addEventListener("message",async e=>{const t=e.data.timeStamp;try{var a;if(/^idb$/i.test(null===(a=e.data)||void 0===a?void 0:a.name)){self.$dbName="prd";const a=(e=!0)=>new Promise(t=>t(e)),r=e=>({error:!0,message:(null==e?void 0:e.message)||e||""}),n=({action:e,prop:t})=>`${e} recieved a wrong data type for ${t}`,o=e=>Array.isArray(e);self.$api||(self.$api={initialized:!1,upgradeCalled:!1,makeTX({action:e,mode:a,onerror:r}){if(!self.$DB)throw new EvalError("no $DB found in iworker.");try{const n=self.$DB.transaction(e,a);return n.onerror=r,n}catch(e){e&&self.postMessage({name:"idb",timeStamp:t,error:!0,errorObject:e})}},transaction({action:e,mode:t,oncomplete:a=(()=>{}),onerror:r}){const n=this.makeTX({action:e,mode:t,onerror:r});if(!n)return{};const o=n.objectStore(e);return n.oncomplete=(e=>{null==a||a({event:e,table:o})}),o},logUpdate(e){e&&this.update({table:"logger",values:[{title:"updated_at",timeStamp:Date.now()}]})},insert({into:e,values:t=[],oncomplete:a,logUpdate:i=!0}){return new Promise((l,s)=>{if(!o(t))return s(r(n({action:"insert",prop:"values"})));const d=this.transaction({action:e,mode:"readwrite",oncomplete:e=>{null==a||a(e),this.logUpdate(i),l(1)}});t.forEach(e=>{try{d.add(e).onerror=(e=>{s(r(e))})}catch(e){s(r(e))}})})},async insertAndView({table:e,values:t=[]}){if((await this.insert({into:e,values:t})).error)return a(null);const r=await this.select({from:e});return a(r)},select({from:e,query:t,count:a,oncomplete:n,index:o}){return new Promise((i,l)=>{let s;const d=this.transaction({action:e,mode:"readonly",oncomplete:({event:e,table:t})=>{var a;let r={event:e,table:t,request:s,result:(null===(a=s)||void 0===a?void 0:a.result)||[]};null==n||n(r),i(r.result),r=0},onerror:e=>{l(r(e))}});try{if(o){const e=d.index(o);s=null==e?void 0:e.getAll()}else s=null==d?void 0:d.getAll(t,a);s.onerror=(e=>{l(r(e))})}catch(e){l(r(e))}})},update({table:e,values:t=[],oncomplete:a,logUpdate:o=!0}){return new Promise((i,l)=>{if(!Array.isArray(t))return l(r(n({action:"update",prop:"values"})));const s=this.transaction({action:e,mode:"readwrite",oncomplete:t=>{null==a||a(t),"logger"!=e&&o&&(this.logUpdate(o),i(t))}});t.forEach(e=>{try{s.put({...e}).onerror=(e=>{l(r(e))})}catch(e){l(r(e))}})})},async updateAndView({table:e,values:t=[]}){if((await this.update({table:e,values:t})).error)return a(null);const r=await this.select({from:e});return a(r)},delete({from:e,keys:t=[],oncomplete:a,clear:i,logUpdate:l=!0}){return new Promise((s,d)=>{if(!o(t)&&!i)return d(r(n({action:"delete",prop:"key"})));const c=this.transaction({action:e,mode:"readwrite",oncomplete:e=>{null==a||a(e),this.logUpdate(l),s(e)}});try{if(i){c.clear().onerror=(e=>{d(r(e))})}else t.forEach(e=>{c.delete(e).onerror=(e=>{d(r(e))})})}catch(e){d(r(e))}})},async deleteAndView({table:e,key:t,clear:r}){if((await this.delete({from:e,key:t,clear:r})).error)return a(null);const n=await this.select({from:e});return a(n)},init({name:e,version:t,stores:n=[{name:"explore",keyPath:"key"},{name:"recipe",keyPath:"id",indexes:[{name:"recipe_id",path:"id"}]},{name:"recently_viewed",keyPath:"path"},{name:"saved",keyPath:"path"},{name:"search",keyPath:"id"},{name:"meta",keyPath:"id"},{name:"sortSaved",keyPath:"ref"}]}){return new Promise((o,i)=>{if(self.$api.initialized)return o(!0);self.$DB||(self.$DB=null);const l=indexedDB.open(e,t);l.addEventListener("upgradeneeded",e=>{self.$DB=e.target.result,self.$api.upgradeCalled=!0;const t=self.$DB,o=({name:e,keyPath:n,indexes:o=[]})=>{const l=()=>{let a;t.objectStoreNames.contains(e)||(a=t.createObjectStore(e,{keyPath:n})),null!=o&&o.length&&o.forEach(e=>{try{a.createIndex(e.name,e.path,e.options||{unique:!1})}catch(e){i(r(e))}})};return t.objectStoreNames.contains(e)?(t.deleteObjectStore(e),l()):l(),a({created:!0})};o({name:"logger",keyPath:"title"}),n.forEach(e=>{o(e)})},{once:!0}),l.onsuccess=(async e=>{self.$DB=e.target.result,self.$api.initialized=!0;const t=Date.now();self.$api.upgradeCalled&&await this.insert({into:"logger",values:[{title:"created_at",timeStamp:t},{title:"updated_at",timeStamp:t},{title:"uid",timeStamp:t,value:`${t.toString(36)}-${performance.now().toString(36)}`.replace(/\./g,"#")}]});const a=await this.select({from:"logger",query:"uid"});o({upgradeCalled:this.upgradeCalled,uid:a})}),l.onerror=(e=>{var t,a;const n=(null==e?void 0:null===(t=e.target)||void 0===t?void 0:null===(a=t.error)||void 0===a?void 0:a.name)||"";i(r({type:n}))})})}});const i=e.data.action;let l=e.data.args;const s=t=>{let a={name:"idb",timeStamp:e.data.timeStamp};if(null!=t&&t.error)a={...a,...t};else{let e=[];try{e=JSON.stringify(t)}catch(t){t&&(e=[])}"string"==typeof e&&(e=JSON.parse(e)),a.data=e}return a};if(["insert","insertAndView","select","update","updateAndView","delete","deleteAndView","init"].includes(i)){const e=await self.$api[i](l);self.postMessage(s(e))}else self.postMessage(s({error:!0,message:"invalid action"}));if(self.$api.upgradeCalled){self.$api.upgradeCalled=!1;const e=await self.$api.select({from:"logger",query:"uid"});null!=e&&e.length&&postMessage({name:"idb",upgradeCalled:!0,data:e[0]})}l=0}}catch(e){var r;e&&/^idb$/i.test(null===(r=e.data)||void 0===r?void 0:r.name)&&self.postMessage({name:"idb",error:!0,errorObject:e})}});